% sdl_bgi-quickref.tex
%
% Guido Gonzato, PhD
% May 28, 2022

\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\thispagestyle{empty}
\usepackage{listings}
\usepackage{color}
\usepackage{alltt}
\usepackage{framed}
\usepackage{setspace}
\usepackage[margin=3cm]{geometry}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\urlstyle{same}
\usepackage[toc]{multitoc}
\renewcommand*{\multicolumntoc}{2}

\frenchspacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{3pt}

\newcommand{\version}{2.6.0}        % !!! <<<=== Change here !!!

\newcommand{\V}{\texttt{void}}      % void
\newcommand{\I}{\texttt{int}}       % int
\newcommand{\Ue}{\texttt{Uint8}}    % Uint8
\newcommand{\Ut}{\texttt{Uint32}}   % Uint32
\newcommand{\C}{\texttt{char *}}    % char *
\newcommand{\func}[1]{\textbf{\texttt{#1}}}  % function
\newcommand{\A}[1]{\emph{#1}}       % parameter
\newcommand{\F}[1]{\texttt{#1}}     % file
\newcommand{\T}[1]{\texttt{#1}}     % constant
\newcommand{\file}[1]{\texttt{#1}}  % file name

\newcommand{\SDLbgi}{\texttt{SDL\_bgi}}

\definecolor{defaultshadecolor}{rgb}{0.85,0.85,1}
\definecolor{shadecolor}{rgb}{0.85,0.85,1}
\definecolor{gray}{rgb}{0.7,0.7,0.7}
\definecolor{charcolor}{rgb}{1,0.85,0.85}
\definecolor{lightred}{rgb}{1,0.7,0.7}
\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{darkred}{rgb}{0.75,0,0}

\newenvironment{bgi}
{ % beg def
  \begin{snugshade}
}
{ % end def
  \end{snugshade}
}

\lstset{
  language=C,
  tabsize=2,
}

% =====

\begin{document}

\title{\SDLbgi{} \version{} Quick Reference}

\author{Guido Gonzato, PhD}

\date{\today}

\maketitle

\begin{center}
  \includegraphics[width=0.5\textwidth]{SDL_bgi_logo.png}
\end{center}

{\small \tableofcontents}

% =====

\section{Introduction to \SDLbgi}

\href{https://sdl_bgi.sourceforge.net}{\SDLbgi} is a multiplatform,
fast, SDL2-based implementation of BGI: the Borland Graphics Interface
also known as \T{GRAPHICS.H}. BGI was a graphics library provided by
Borland Turbo C / Borland C++ compilers for DOS, and it was very
popular in the late eighties--early nineties of the last century. It
became the \emph{de facto} standard for computer graphics, especially
in education. For more information, please see 
\href{https://en.wikipedia.org/wiki/Borland_Graphics_Interface}{the
Wikipedia article}.

% \SDLbgi{} is fully compatible with the BGI implementation of Turbo C
% 2.01.

However, \SDLbgi{} is not meant to be just a replica of BGI; it aims
to be a functionally equivalent superset. It provides many extensions
for ARGB colours, multiple windows, bitmap and vector fonts, and mouse
support. \SDLbgi{} implements nearly all extensions provided by
another popular BGI implementation, WinBGIm, and adds several more.
Please see \href{http://www.codecutter.net/tools/winbgim}{this page}
for more information on WinBGIm.

\SDLbgi{} is one of the easiest libraries to do graphics programming
in C. It is much simpler to use than plain SDL2, OpenGL and the like;
obviously, it's less complete. Teachers may find \SDLbgi{} a useful
tool for introductory computer graphics courses.

For example, this is a minimal program that opens a  window and draws
1000 random lines:

\begin{small}
\begin{spacing}{0.9}
\begin{verbatim}
#include <graphics.h>

int main (int argc, char *argv[])
{
  int i, gd = DETECT, gm;
  initgraph (&gd, &gm, ""); // default: 800 x 600
  setbkcolor (BLACK);
  cleardevice ();
  outtextxy (0, 0, "Drawing 1000 lines...");
  for (i = 0; i < 1000; i++) {
    setcolor (1 + random (15));
    line (random(getmaxx()), random(getmaxy()),
    random (getmaxx()), random(getmaxy()) );
  }
  getch ();
  closegraph ();
  return 0;
}
\end{verbatim}
\end{spacing}
\end{small}

The program includes the header file \F{graphics.h}, which in turn
includes \F{SDL\_bgi.h} that contains all necessary definitions. The
call to \func{initgraph()} opens a window; from now on, graphics
functions may be called. \func{closegraph()} closes the window.

Within the window, pixel coordinates range from the upper left corner
at (0, 0) to the lower right corner at (\func{get\-maxx()},
\func{getmaxy()}).

Some graphic functions set the coordinates of the last drawing
position, defined as CP (Current Position). At any given moment, a
foreground, background and fill colour, line style, line thickness,
and fill pattern, are defined. A viewport (subwindow) may also be
defined, with or without clipping. All of these parameters can be
changed using appropriate functions.

\SDLbgi{} programs can be compiled to native code on several
platforms, and also to WebAssembly using Emscripten.

% -----

\subsection{Constants}

\F{SDL\_bgi.h} contains many definitions the programmer should be
aware of. The most important are the following:

\begin{small}
\begin{spacing}{0.85}
\begin{verbatim}
#ifndef _SDL_BGI_H
#define _SDL_BGI_H

#ifndef __GRAPHICS_H
#define __GRAPHICS_H

// SDL2 stuff
#include <SDL2/SDL.h>
#include <SDL2/SDL_keycode.h>
#include <SDL2/SDL_mouse.h>
#include <stdio.h>   // for fprintf()
#include <stdlib.h>  // for exit(), calloc()
#include <math.h>    // for sin(), cos()
#include <string.h>  // for strlen(), memcpy()

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

#define SDL_BGI_VERSION 2.6.0

enum { NOPE, YEAH } ;
#define BGI_WINTITLE_LEN 512 // more than enough

// number of concurrent windows that can be created

#define NUM_BGI_WIN 16

// everything gets drawn here

extern SDL_Window   *bgi_window;
extern SDL_Renderer *bgi_renderer;
extern SDL_Texture  *bgi_texture;
extern Uint32        PALETTE_SIZE;

// available visual pages

#define VPAGES 4

// BGI fonts

enum {
  DEFAULT_FONT,      // 8x8 bitmap
  TRIPLEX_FONT,      // trip.h
  SMALL_FONT,        // litt.h
  SANS_SERIF_FONT,   // sans.h
  GOTHIC_FONT,       // goth.h
  SCRIPT_FONT,       // scri.h
  SIMPLEX_FONT,      // simp.h
  TRIPLEX_SCR_FONT,  // tscr.h
  COMPLEX_FONT,      // lcom.h
  EUROPEAN_FONT,     // euro.h
  BOLD_FONT,         // bold.h
  LAST_SPEC_FONT
};

enum { HORIZ_DIR, VERT_DIR };

#define USER_CHAR_SIZE 0

enum {
  LEFT_TEXT, CENTER_TEXT, RIGHT_TEXT,
  BOTTOM_TEXT = 0, TOP_TEXT = 2
};

// BGI colours, including CGA and EGA palettes

enum {
  BLACK        = 0,                         EGA_BLACK        = 0,
  BLUE         = 1,                         EGA_BLUE         = 1,
  GREEN        = 2,  CGA_GREEN        = 2,  EGA_GREEN        = 2,
  CYAN         = 3,  CGA_CYAN         = 3,  EGA_CYAN         = 3,
  RED          = 4,  CGA_RED          = 4,  EGA_RED          = 4,
  MAGENTA      = 5,  CGA_MAGENTA      = 5,  EGA_MAGENTA      = 5,
  BROWN        = 6,  CGA_BROWN        = 6,  EGA_BROWN        = 6,
  LIGHTGRAY    = 7,  CGA_LIGHTGRAY    = 7,  EGA_LIGHTGRAY    = 7,
  DARKGRAY     = 8,                         EGA_DARKGRAY     = 8,
  LIGHTBLUE    = 9,                         EGA_LIGHTBLUE    = 9,
  LIGHTGREEN   = 10, CGA_LIGHTGREEN   = 10, EGA_LIGHTGREEN   = 10,
  LIGHTCYAN    = 11, CGA_LIGHTCYAN    = 11, EGA_LIGHTCYAN    = 11,
  LIGHTRED     = 12, CGA_LIGHTRED     = 12, EGA_LIGHTRED     = 12,
  LIGHTMAGENTA = 13, CGA_LIGHTMAGENTA = 13, EGA_LIGHTMAGENTA = 13,
  YELLOW       = 14, CGA_YELLOW       = 14, EGA_YELLOW       = 14,
  WHITE        = 15, CGA_WHITE        = 15, EGA_WHITE        = 15,
  MAXCOLORS    = 15
};

// ARGB colours, set by COLOR (), COLOR32 (), and RGBPALETTE ()

enum {
  ARGB_FG_COL   = 16,
  ARGB_BG_COL   = 17,
  ARGB_FILL_COL = 18,
  ARGB_TMP_COL  = 19,
  TMP_COLORS    = 4
};

// line style, thickness, and drawing mode

enum { NORM_WIDTH = 1, THICK_WIDTH = 3 };

enum { SOLID_LINE, DOTTED_LINE, CENTER_LINE, DASHED_LINE, USERBIT_LINE };

enum { COPY_PUT, XOR_PUT, OR_PUT, AND_PUT, NOT_PUT };

// fill styles

enum {
  EMPTY_FILL,       // fills area in background color
  SOLID_FILL,       // fills area in solid fill color
  LINE_FILL,        // --- fill
  LTSLASH_FILL,     // /// fill
  SLASH_FILL,       // /// fill with thick lines
  BKSLASH_FILL,     // \\\ fill with thick lines
  LTBKSLASH_FILL,   // \\\ fill
  HATCH_FILL,       // light hatch fill
  XHATCH_FILL,      // heavy cross hatch fill
  INTERLEAVE_FILL,  // interleaving line fill
  WIDE_DOT_FILL,    // Widely spaced dot fill
  CLOSE_DOT_FILL,   // Closely spaced dot fill
  USER_FILL         // user defined fill
};

// mouse events - compatible with WinBGIm

#define WM_MOUSEMOVE       SDL_MOUSEMOTION

#define WM_LBUTTONDOWN     SDL_BUTTON_LEFT
#define WM_LBUTTONUP       SDL_MOUSEBUTTONUP   + SDL_BUTTON_LEFT
#define WM_LBUTTONDBLCLK   SDL_MOUSEBUTTONDOWN + SDL_BUTTON_LEFT + 2

#define WM_MBUTTONDOWN     SDL_BUTTON_MIDDLE
#define WM_MBUTTONUP       SDL_MOUSEBUTTONUP   + 10*SDL_BUTTON_MIDDLE
#define WM_MBUTTONDBLCLK   SDL_MOUSEBUTTONDOWN + 10*SDL_BUTTON_MIDDLE + 2

#define WM_RBUTTONDOWN     SDL_BUTTON_RIGHT
#define WM_RBUTTONUP       SDL_MOUSEBUTTONUP   + 20*SDL_BUTTON_RIGHT
#define WM_RBUTTONDBLCLK   SDL_MOUSEBUTTONDOWN + 20*SDL_BUTTON_RIGHT + 2

#define WM_WHEEL           SDL_MOUSEWHEEL
#define WM_WHEELUP         SDL_BUTTON_RIGHT + 1
#define WM_WHEELDOWN       SDL_BUTTON_RIGHT + 2

// keys
#define KEY_HOME        SDLK_HOME
#define KEY_LEFT        SDLK_LEFT
#define KEY_UP          SDLK_UP
#define KEY_RIGHT       SDLK_RIGHT
#define KEY_DOWN        SDLK_DOWN
#define KEY_PGUP        SDLK_PAGEUP
#define KEY_PGDN        SDLK_PAGEDOWN
#define KEY_END         SDLK_END
#define KEY_INSERT      SDLK_INSERT
#define KEY_DELETE      SDLK_DELETE
#define KEY_F1          SDLK_F1
#define KEY_F2          SDLK_F2
#define KEY_F3          SDLK_F3
#define KEY_F4          SDLK_F4
#define KEY_F5          SDLK_F5
#define KEY_F6          SDLK_F6
#define KEY_F7          SDLK_F7
#define KEY_F8          SDLK_F8
#define KEY_F9          SDLK_F9
#define KEY_F10         SDLK_F10
#define KEY_F11         SDLK_F11
#define KEY_F12         SDLK_F12
#define KEY_CAPSLOCK    SDLK_CAPSLOCK
#define KEY_LEFT_CTRL   SDLK_LCTRL
#define KEY_RIGHT_CTRL  SDLK_RCTRL
#define KEY_LEFT_SHIFT  SDLK_LSHIFT
#define KEY_RIGHT_SHIFT SDLK_RSHIFT
#define KEY_LEFT_ALT    SDLK_LALT
#define KEY_RIGHT_ALT   SDLK_RALT
#define KEY_ALT_GR      SDLK_MODE
#define KEY_LGUI        SDLK_LGUI
#define KEY_RGUI        SDLK_RGUI
#define KEY_MENU        SDLK_MENU
#define KEY_TAB         SDLK_TAB
#define KEY_BS          SDLK_BACKSPACE
#define KEY_RET         SDLK_RETURN
#define KEY_PAUSE       SDLK_PAUSE
#define KEY_SCR_LOCK    SDLK_SCROLLOCK
#define KEY_ESC         SDLK_ESCAPE

#define QUIT            SDL_QUIT

// graphics modes. Expanded from the original GRAPHICS.H

enum {
  DETECT = -1,
  SDL = 0,
  // all modes @ 320x200
  SDL_320x200 = 1, SDL_CGALO = 1, CGA = 1, CGAC0 = 1, CGAC1 = 1,
  CGAC2 = 1, CGAC3 = 1, MCGAC0 = 1, MCGAC1 = 1, MCGAC2 = 1,
  MCGAC3 = 1, ATT400C0 = 1, ATT400C1 = 1, ATT400C2 = 1, ATT400C3 = 1,
  // all modes @ 640x200
  SDL_640x200 = 2, SDL_CGAHI = 2, CGAHI = 2, MCGAMED = 2,
  EGALO = 2, EGA64LO = 2,
  // all modes @ 640x350
  SDL_640x350 = 3, SDL_EGA = 3, EGA = 3, EGAHI = 3,
  EGA64HI = 3, EGAMONOHI = 3,
  // all modes @ 640x480
  SDL_640x480 = 4, SDL_VGA = 4, VGA = 4, MCGAHI = 4, VGAHI = 4,
  IBM8514LO = 4,
  // all modes @ 720x348
  SDL_720x348 = 5, SDL_HERC = 5,
  // all modes @ 720x350
  SDL_720x350 = 6, SDL_PC3270 = 6, HERCMONOHI = 6,
  // all modes @ 800x600
  SDL_800x600 = 7, SDL_SVGALO = 7, SVGA = 7,
  // all modes @ 1024x768
  SDL_1024x768 = 8, SDL_SVGAMED1 = 8,
  // all modes @ 1152x900
  SDL_1152x900 = 9, SDL_SVGAMED2 = 9,
  // all modes @ 1280x1024
  SDL_1280x1024 = 10, SDL_SVGAHI = 10,
  // all modes @ 1366x768
  SDL_1366x768 = 11, SDL_WXGA = 11,
  // other
  SDL_USER = 12, SDL_FULLSCREEN = 13
};

// error messages
enum graphics_errors {
  grOk               =   0,
  grNoInitGraph      =  -1,
  grNotDetected      =  -2,
  grFileNotFound     =  -3,
  grInvalidDriver    =  -4,
  grNoLoadMem        =  -5,
  grNoScanMem        =  -6,
  grNoFloodMem       =  -7,
  grFontNotFound     =  -8,
  grNoFontMem        =  -9,
  grInvalidMode      = -10,
  grError            = -11,
  grIOerror          = -12,
  grInvalidFont      = -13,
  grInvalidFontNum   = -14,
  grInvalidVersion   = -18
};

// libXbgi compatibility

#define X11_CGALO       SDL_CGALO
#define X11_CGAHI       SDL_CGAHI
#define X11_EGA         SDL_EGA
#define X11             SDL
#define X11_VGA         SDL_VGA
#define X11_640x480     SDL_640x480
#define X11_HERC        SDL_HERC
#define X11_PC3270      SDL_PC3270
#define X11_SVGALO      SDL_SVGALO
#define X11_800x600     SDL_800x600
#define X11_SVGAMED1    SDL_SVGAMED1
#define X11_1024x768    SDL_1024x768
#define X11_SVGAMED2    SDL_SVGAMED2
#define X11_1152x900    SDL_1152x900
#define X11_SVGAHI      SDL_SVGAHI
#define X11_1280x1024   SDL_1280x1024
#define X11_WXGA        SDL_WXGA
#define X11_1366x768    SDL_1366x768
#define X11_USER        SDL_USER
#define X11_FULLSCREEN  SDL_FULLSCREEN

// structs

struct arccoordstype {
  int x;
  int y;
  int xstart;
  int ystart;
  int xend;
  int yend;
};

struct date {
  int da_year;
  int da_day;
  int da_mon;
};

struct fillsettingstype {
  int pattern;
  int color;
};

struct linesettingstype {
  int linestyle;
  unsigned int upattern;
  int thickness;
};

struct palettetype {
  unsigned char size;
  signed char colors[MAXCOLORS + 1];
};

// SDL_bgi extension
struct rgbpalettetype {
  Uint32 size;
  Uint32 *colors;
};

struct textsettingstype {
  int font;
  int direction;
  int charsize;
  int horiz;
  int vert;
};

struct viewporttype {
  int left;
  int top;
  int right;
  int bottom;
  int clip;
};
\end{verbatim}
\end{spacing}
\end{small}

% -----

\subsection{Environment Variables}

\T{SDL\_BGI\_RES}: when set to \T{VGA}, default resolution will be 640
$\times$ 480 instead of default 800 $\times$ 600. Please see
\func{initgraph()} (page \pageref{sec:initgraph}) for details.

\T{SDL\_BGI\_RATE}: when set to \T{auto}, automatic screen refresh
will be performed. Please see \func{initgraph()} (page
\pageref{sec:initgraph}) for details.

\T{SDL\_BGI\_PALETTE}: when set to \T{BGI}, the first 16 colours will
use the same RGB values as Turbo C 2.01. Please see
\func{initpalette()} (page \pageref{sec:initpalette}) for details.

% -----

\subsection{Colours}

The default BGI palette includes 16 named colours (\T{BLACK}{\ldots}
\T{WHITE}); functions \func{getbkcolor()}, \func{getcolor()},
\func{putpixel()}, \func{setbkcolor()} \func{setbkcolor()},
\func{setco\-lor()}, \func{setfillpattern()}, \func{setfillstyle()}
and \func{setpalette()} use this palette by default.

An extended ARGB palette of \T{PALETTE\_SIZE} additional colours can
be created and accessed using functions \func{getrgbpalette()},
\func{setallpalette()}, \func{setbkrgbcolor()}, \func{setrbgcolor()}
and \func{setrbgpalette()}. These functions are functionally
equivalent to their standard BGI counterparts. \T{PALETTE\_SIZE} is
4096 by default; the palette can be resized using
\func{resizepalette()}.

Standard BGI functions can also use ARGB colours using \func{COLOR()},
\func{COLOR32()}, and \func{RGBPALETTE()} as colour parameter; see
sample programs in directory \file{test/}.

At any given moment, either the BGI or the ARGB palette is being used.
Functions \T{IS\_BGI\_COLOR} and \T{IS\_RGB\_COLOR} return 1 if the
corresponding palette is being used.

Constants \T{ARGB\_FG\_COL}, \T{ARGB\_BG\_COL}, \T{ARGB\_FILL\_COL},
and \T{ARGB\_TMP\_COL} denote the foreground, background, fill, and
temporary ARGB colours that can be set with functions \func{COLOR()},
\func{COLOR32()}, and \func{RGBPALETTE()}.

% -----

\subsection{Fonts}

\SDLbgi{} provides an 8$\times$8 bitmap font and vector fonts decoded
from original \T{.CHR} files; loading \T{.CHR} fonts from disk is also
possible. Please see \func{settextstyle()} (page
\pageref{sec:settextstyle}) for details.

\T{.CHR} font support was added by Marco Diego Aur\'elio Mesquita.


% -----

\subsection{Note for SDL2 Programmers}

The following variables are declared in \F{SDL\_bgi.h}, and are
accessible to the programmer:

\begin{small}
\begin{spacing}{0.85}
\begin{verbatim}
SDL_Window   *bgi_window;
SDL_Renderer *bgi_renderer;
SDL_Texture  *bgi_texture;
Uint32       PALETTE_SIZE;
\end{verbatim}
\end{spacing}
\end{small}

and can be used by native SDL2 functions. That is, you can use BGI and
native SDL2 functions together, as in the following code snippet:

\begin{small}
\begin{spacing}{0.85}
\begin{verbatim}
SDL_Surface *bitmap;
SDL_Texture *texture;
...
bitmap = SDL_LoadBMP ("picture.bmp");
texture = SDL_CreateTextureFromSurface (bgi_renderer, bitmap);
SDL_RenderCopy (bgi_renderer, texture, NULL, NULL);
SDL_RenderPresent (bgi_renderer);
...
\end{verbatim}
\end{spacing}
\end{small}

Please see \file{test/loadimage.c} for a complete example.

% -----

\section{Standard BGI Graphics Functions}

The following are standard BGI functions, as implemented for example
in Turbo C. They are all prototyped in \F{SDL\_bgi.h}.

Unless otherwise specified, graphics routines draw shapes using the
current drawing colour, i.e.\ as specified by \func{setcolor()}.

% -----

\addcontentsline{toc}{subsection}{\T{arc()}}
\phantomsection\label{sec:arc}

\begin{bgi}
  \V{} \func{arc} (\I{} \A{x}, \I{} \A{y}, \I{} \A{stangle}, \I{}
  \A{endangle}, \I{} \A{radius});
\end{bgi}

Draws a circular arc centered at (\A{x}, \A{y}), with a radius given
by \A{radius}, traveling from \A{stangle} to \A{endangle}. The angle
for \func{arc()} is measured counterclockwise, with 0 degrees at 3 o'
clock, 90 degrees at 12 o' clock, etc.

\textbf{Note}: The \A{linestyle} parameter does not affect arcs,
circles, ellipses, or pie\-slices. Only the \A{thickness} parameter is
used.

% -----

\addcontentsline{toc}{subsection}{\T{bar()}}
\phantomsection\label{sec:bar}

\begin{bgi}
\V{} \func{bar} (\I{} \A{left}, \I{} \A{top}, \I{} \A{right}, \I{}
\A{bottom});
\end{bgi}

Draws a filled-in rectangle (bar), using the current fill colour and
fill pattern. The bar is not outlined; to draw an outlined
two-dimensional bar, use \func{bar3d()} with \A{depth} equal to 0.

% -----

\addcontentsline{toc}{subsection}{\T{bar3d()}}
\phantomsection\label{sec:bar3d}

\begin{bgi}
\V{} \func{bar3d} (\I{} \A{left}, \I{} \A{top}, \I{} \A{right}, \I{}
\A{bottom}, \I{} \A{depth}, \I{} \A{topflag});
\end{bgi}

Draws a three-dimensional, filled-in rectangle (bar), using the
current fill colour and fill pattern. The three-dimensional outline of
the bar is drawn in the current line style and colour. The bar's
depth, in pixels, is given by \A{depth}. If \A{topflag} is nonzero, a
top is put on.

% -----

\addcontentsline{toc}{subsection}{\T{circle()}}
\phantomsection\label{sec:circle}

\begin{bgi}
\V{} \func{circle} (\I{} \A{x}, \I{} \A{y}, \I{} \A{radius});
\end{bgi}

Draws a circle of the given \A{radius} at (\A{x}, \A{y}).

\textbf{Note}: The \A{linestyle} parameter does not affect arcs,
circles, ellipses, or pie\-slices. Only the \A{thickness} parameter is
used.

% -----

\addcontentsline{toc}{subsection}{\T{cleardevice()}}
\phantomsection\label{sec:cleardevice}

\begin{bgi}
\V{} \func{cleardevice} (\V{});
\end{bgi}

Clears the graphics screen, filling it with the current background
colour. The CP is moved to (0, 0).

% -----

\addcontentsline{toc}{subsection}{\T{clearviewport()}}
\phantomsection\label{sec:clearviewport}

\begin{bgi}
\V{} \func{clearviewport} (\V{});
\end{bgi}

Clears the viewport, filling it with the current background colour.
The CP is moved to (0, 0), relative to the viewport.

% -----

\addcontentsline{toc}{subsection}{\T{closegraph()}}
\phantomsection\label{sec:closegraph}

\begin{bgi}
\V{} \func{closegraph} (\V{});
\end{bgi}

Closes the graphics system. In Emscripten, it closes the browser tab
or window.

% -----

\addcontentsline{toc}{subsection}{\T{detectgraph()}}
\phantomsection\label{sec:detectgraph}

\begin{bgi}
\V{} \func{detectgraph} (\I{} \A{*graphdriver}, \I{} \A{*graphmode});
\end{bgi}

Detects the graphics driver and default graphics mode to use; \T{SDL}
and \T{SDL\_FULL\-SCREEN}, respectively.

% -----

\addcontentsline{toc}{subsection}{\T{drawpoly()}}
\phantomsection\label{sec:drawpoly}

\begin{bgi}
\V{} \func{drawpoly} (\I{} \A{numpoints}, \I{} \A{*polypoints});
\end{bgi}

Draws a polygon of \A{numpoints} vertices. \A{polypoints} is a
pointer to a sequence of (2 * \A{numpoints}) integers; each pair gives
the \A{x} and \A{y} coordinate of each vertex.

% -----

\addcontentsline{toc}{subsection}{\T{ellipse()}}
\phantomsection\label{sec:ellipse}

\begin{bgi}
\V{} \func{ellipse} (\I{} \A{x}, \I{} \A{y}, \I{} \A{stangle}, \I{}
\A{endangle}, \I{} \A{xradius}, \I{} \A{yradius});
\end{bgi}

Draws an elliptical arc centered at (\A{x}, \A{y}), with axes given by
\A{xradius} and \A{yradius}, traveling from \A{stangle} to
\A{endangle}.

% -----

\addcontentsline{toc}{subsection}{\T{fillellipse()}}
\phantomsection\label{sec:fillellipse}

\begin{bgi}
\V{} \func{fillellipse} (\I{} \A{x}, \I{} \A{y}, \I{} \A{xradius},
\I{} \A{yradius});
\end{bgi}

Draws an ellipse centered at (\A{x}, \A{y}), with axes given by
\A{xradius} and \A{yradius}, and fills it using the current fill
colour and fill pattern.

% -----

\addcontentsline{toc}{subsection}{\T{fillpoly()}}
\phantomsection\label{sec:fillpoly}

\begin{bgi}
\V{} \func{fillpoly} (\I{} \A{numpoints}, \I{} \A{*polypoints});
\end{bgi}

Draws a polygon of \A{numpoints} vertices and fills it using the
current fill colour.

% -----

\addcontentsline{toc}{subsection}{\T{floodfill()}}
\phantomsection\label{sec:floodfill}

\begin{bgi}
\V{} \func{floodfill} (\I{} \A{x}, \I{} \A{y}, \I{} \A{border});
\end{bgi}

Fills an enclosed area, containing the \A{x} and \A{y} points bounded
by the \A{border} colour. The area is filled using the current fill
colour.

% -----

\addcontentsline{toc}{subsection}{\T{getactivepage()}}
\phantomsection\label{sec:getactivepage}

\begin{bgi}
\I{} \func{getactivepage} (\V{});
\end{bgi}

Returns the active page number.

% -----

\addcontentsline{toc}{subsection}{\T{getarccoords()}}
\phantomsection\label{sec:getarccoords}

\begin{bgi}
\V{} \func{getarccoords} (\T{struct arccoordstype} \A{*arccoords});
\end{bgi}

Gets the coordinates of the last call to \func{arc()}, filling the
\A{arccoords} structure.

% -----

\addcontentsline{toc}{subsection}{\T{getaspectratio()}}
\phantomsection\label{sec:getaspectratio}

\begin{bgi}
\V{} \func{getaspectratio} (\I{} \A{*xasp}, \I{} \A{*yasp});
\end{bgi}

Retrieves the current graphics mode's aspect ratio. In \SDLbgi,
\A{xasp} and \A{yasp} are both 10000 (i.e. pixels are square).

% -----

\addcontentsline{toc}{subsection}{\T{getbkcolor()}}
\phantomsection\label{sec:getbkcolor}

\begin{bgi}
\I{} \func{getbkcolor} (\V{});
\end{bgi}

Returns the current background colour.

% -----

\addcontentsline{toc}{subsection}{\T{getcolor()}}
\phantomsection\label{sec:getcolor}

\begin{bgi}
\I{} \func{getcolor} (\V{});
\end{bgi}

Returns the current drawing (foreground) colour in the default
palette. If the foregroud colour was set by \func{COLOR()},
\func{getcolor()} returns -1.

% -----

\addcontentsline{toc}{subsection}{\T{getdefaultpalette()}}
\phantomsection\label{sec:getdefaultpalette}

\begin{bgi}
\T{struct palettetype} \func{*getdefaultpalette} (\V{});
\end{bgi}

Returns the palette definition structure.

% -----

\addcontentsline{toc}{subsection}{\T{getdrivername()}}
\phantomsection\label{sec:getdrivername}

\begin{bgi}
\C{}\func{getdrivername} (\V{});
\end{bgi}

Returns a pointer to a string containing the name of the current
graphics driver.

% -----

\addcontentsline{toc}{subsection}{\T{getfillpattern()}}
\phantomsection\label{sec:getfillpattern}

\begin{bgi}
\V{} \func{getfillpattern} (\C{}\A{pattern});
\end{bgi}

Copies the user-defined fill pattern, as set by setfillpattern, into
the 8-byte area pointed to by \A{pattern}.

% -----

\addcontentsline{toc}{subsection}{\T{getfillsettings()}}
\phantomsection\label{sec:getfillsettings}

\begin{bgi}
\V{} \func{getfillsettings} (\T{struct fillsettingstype}
\A{*fillinfo});
\end{bgi}

Fills the \T{fillsettingstype} structure pointed to by
\A{fillinfo} with information about the current fill pattern and fill
colour.

% -----

\addcontentsline{toc}{subsection}{\T{getgraphmode()}}
\phantomsection\label{sec:getgraphmode}

\begin{bgi}
\I{} \func{getgraphmode} (\V{});
\end{bgi}

Returns the current graphics mode.

% -----

\addcontentsline{toc}{subsection}{\T{getimage()}}
\phantomsection\label{sec:getimage}

\begin{bgi}
\V{} \func{getimage} (\I{} \A{left}, \I{} \A{top}, \I{} \A{right},
\I{} \A{bottom}, \V{} \A{*bitmap});
\end{bgi}

Copies a bit image of the specified region into the memory pointed by
\A{bitmap}.

% -----

\addcontentsline{toc}{subsection}{\T{getlinesettings()}}
\phantomsection\label{sec:getlinesettings}

\begin{bgi}
\V{} \func{getlinesettings} (\T{struct linesettingstype}
\A{*lineinfo});
\end{bgi}

Fills the \T{linesettingstype} structure pointed by \A{lineinfo}
with information about the current line style, pattern, and thickness.

% -----

\addcontentsline{toc}{subsection}{\T{getmaxcolor()}}
\phantomsection\label{sec:getmaxcolor}

\begin{bgi}
\I{} \func{getmaxcolor} (\V{});
\end{bgi}

Returns the maximum colour value available (\T{MAXCOLORS}). If ARGB
colours are being used, it returns \T{PALETTE\_SIZE}.

% -----

\addcontentsline{toc}{subsection}{\T{getmaxmode()}}
\phantomsection\label{sec:getmaxmode}

\begin{bgi}
\I{} \func{getmaxmode} (\V{});
\end{bgi}

Returns the maximum mode number for the current driver. In \SDLbgi,
the default is \T{SDL\_FULLSCREEN}.

% -----

\addcontentsline{toc}{subsection}{\T{getmaxx()}}
\phantomsection\label{sec:getmaxx}

\begin{bgi}
\I{} \func{getmaxx} (\V{});
\end{bgi}

Returns the maximum \A{x} screen coordinate.

% -----

\addcontentsline{toc}{subsection}{\T{getmaxy()}}
\phantomsection\label{sec:getmaxy}

\begin{bgi}
\I{} \func{getmaxy} (\V{});
\end{bgi}

Returns the maximum \A{y} screen coordinate.

% -----

\addcontentsline{toc}{subsection}{\T{getmodename()}}
\phantomsection\label{sec:getmodename}

\begin{bgi}
\T{char*} \func{getmodename} (\I{} \A{mode\_number});
\end{bgi}

Returns a pointer to a string containing the name of the specified
graphics mode.

% -----

\addcontentsline{toc}{subsection}{\T{getmoderange()}}
\phantomsection\label{sec:getmoderange}

\begin{bgi}
\V{} \func{getmoderange} (\I{} \A{graphdriver}, \I{} \A{*lomode}, \I{}
\A{*himode});
\end{bgi}

Returns the range of valid graphics modes. The \A{graphdriver} parameter
is ignored.

% -----

\addcontentsline{toc}{subsection}{\T{getpalette()}}
\phantomsection\label{sec:getpalette}

\begin{bgi}
\V{} \func{getpalette} (\T{struct palettetype} \A{*palette});
\end{bgi}

Fills the \T{palettetype} structure pointed by \A{palette} with
information about the current palette's size and colours.

% -----

\addcontentsline{toc}{subsection}{\T{getpalettesize()}}
\phantomsection\label{sec:getpalettesize}

\begin{bgi}
\I{} \func{getpalettesize} (\V{});
\end{bgi}

Returns the size of the palette (\T{MAXCOLORS} + 1 or
\T{MAXRGB\-COLORS} + 1).

% -----

\addcontentsline{toc}{subsection}{\T{getpixel()}}
\phantomsection\label{sec:getpixel}

\begin{bgi}
\I{} \func{getpixel} (\I{} \A{x}, \I{} \A{y});
\end{bgi}

Returns the colour of the pixel located at (\A{x}, \A{y}).

% -----

\addcontentsline{toc}{subsection}{\T{gettextsettings()}}
\phantomsection\label{sec:gettextsettings}

\begin{bgi}
\V{} \func{gettextsettings} (\T{struct textsettingstype}
\A{*texttypeinfo});
\end{bgi}

Fills the \T{textsettingstype} structure pointed to by
\A{texttypeinfo} with information about the current text font,
direction, size, and justification.

% -----

\addcontentsline{toc}{subsection}{\T{getviewsettings()}}
\phantomsection\label{sec:getviewsettings}

\begin{bgi}
\V{} \func{getviewsettings} (\T{struct viewporttype} \A{*viewport});
\end{bgi}

Fills the \T{viewporttype} structure pointed to by \A{viewport}
with information about the current viewport.

% -----

\addcontentsline{toc}{subsection}{\T{getvisualpage()}}
\phantomsection\label{sec:getvisualpage}

\begin{bgi}
\I{} \func{getvisualpage} (\V{});
\end{bgi}

Returns the visual page number.

% -----

\addcontentsline{toc}{subsection}{\T{getx()}}
\phantomsection\label{sec:getx}

\begin{bgi}
\I{} \func{getx} (\V{});
\end{bgi}

Returns the current viewport's \A{x} coordinate.

% -----

\addcontentsline{toc}{subsection}{\T{gety()}}
\phantomsection\label{sec:gety}

\begin{bgi}
\I{} \func{gety} (\V{});
\end{bgi}

Returns the current viewport's \A{y} coordinate.

% -----

\addcontentsline{toc}{subsection}{\T{graphdefaults()}}
\phantomsection\label{sec:graphdefaults}

\begin{bgi}
\V{} \func{graphdefaults} (\V{});
\end{bgi}

Resets all graphics settings to their default values: sets the
viewport to the entire screen, moves the CP to (0, 0), sets the
default palette colours, the default drawing and background colour,
the default fill style and pattern, the default text font and
justification.

% -----

\addcontentsline{toc}{subsection}{\T{grapherrormsg()}}
\phantomsection\label{sec:grapherrormsg}

\begin{bgi}
\T{char*} \func{grapherrormsg} (\I{} \A{errorcode});
\end{bgi}

Returns a pointer to the error message string associated with
\A{errorcode}, returned by \func{graphresult()}.

% -----

\addcontentsline{toc}{subsection}{\T{graphresult()}}
\phantomsection\label{sec:graphresult}

\begin{bgi}
\I{} \func{graphresult} (\V{});
\end{bgi}

Returns the error code for the last unsuccessful graphics operation
and resets the error level to \T{grOk}.

% -----

\addcontentsline{toc}{subsection}{\T{imagesize()}}
\phantomsection\label{sec:imagesize}

\begin{bgi}
\T{unsigned} \func{imagesize} (\I{} \A{left}, \I{} \A{top}, \I{}
\A{right}, \I{} \A{bottom});
\end{bgi}

Returns the size in bytes of the memory area required to store a bit
image.

% -----

\addcontentsline{toc}{subsection}{\T{initgraph()}}
\phantomsection\label{sec:initgraph}

\begin{bgi}
\V{} \func{initgraph} (\I{} \A{*graphdriver}, \I{} \A{*graphmode},
\C{}\A{pathtodriver});
\end{bgi}

Initializes the graphics system. In \SDLbgi, you can use SDL as
\A{graphdriver}, then choose a suitable graphics mode (listed in
\F{graphics.h}) as \A{graphmode}. The \A{pathtodriver} argument is
ignored. Typically, \A{graphdriver} is set to \T{DETECT}, and
\A{graphmode} is not set; these values will set the default resolution
(800 $\times$ 600) as \T{SVGA}. If the environment variable
\T{SDL\_BGI\_RES} equals \T{VGA} or \T{vga}, then VGA resolution (640
$\times$ 480) will be forced.

You can also use \T{NULL} for \A{*graphdriver} and \A{*graphmode} to
get the default resolution (800 $\times$ 600), or use
\func{detectgraph()} (see above) to get fullscreen.

Multiple windows can be created, unless a fullscreen window is already
present.

Using \func{initgraph()}, the default 16-colour palette uses the same
ARGB values as the original palette in Turbo C. Using
\func{initwindow()}, the default 16-colour palette uses different
(possibly, better-looking) ARGB values.

After \func{initgraph()}, all graphics commands are immediately
displayed, as in the original BGI. This could make drawing very slow;
you may want to use \func{initwindow()} instead.

Alternatively, automatic screen refresh can be performed according to
the value of the \T{SDL\_BGI\_RATE} environment variable. If the
variable is set to \T{auto}, screen refresh is automatically performed
every \A{msec} milliseconds; this value is the current screen refresh
rate, as given by \T{SDL\_GetDisplayMode()}. If the variable is set to
an integer value \A{msec}, automatic screen refresh will be performed
every \A{msec} milliseconds.

Automatic screen refresh is much faster than the default behaviour;
however, this feature may not work on some graphic cards.

% -----

\addcontentsline{toc}{subsection}{\T{installuserdriver()}}
\phantomsection\label{sec:installuserdriver}

\begin{bgi}
\I{} \func{installuserdriver} (\C{}\A{name}, \I{} (\A{*detect})(\V{}));
\end{bgi}

Unimplemented; not used by \SDLbgi.

% -----

\addcontentsline{toc}{subsection}{\T{installuserfont()}}
\phantomsection\label{sec:installuserfont}

\begin{bgi}
\I{} \func{installuserfont} (\C{}\A{name});
\end{bgi}

Loads and installs a \file{.CHR} font from disk. The function returns
an integer to be used as first argument in \func{settextstyle()}.

\emph{Note:} font metrics of loaded \file{.CHR} files are not
pixel-perfect yet.

% -----

\addcontentsline{toc}{subsection}{\T{line()}}
\phantomsection\label{sec:line}

\begin{bgi}
\V{} \func{line} (\I{} \A{x1}, \I{} \A{y1}, \I{} \A{x2}, \I{} \A{y2});
\end{bgi}

Draws a line between two specified points; the CP is not updated.

% -----

\addcontentsline{toc}{subsection}{\T{linerel()}}
\phantomsection\label{sec:linerel}

\begin{bgi}
\V{} \func{linerel} (\I{} \A{dx}, \I{} \A{dy});
\end{bgi}

Draws a line from the CP to a point that is (\A{dx}, \A{dy}) pixels
from the CP. The CP is then advanced by (\A{dx}, \A{dy}).

% -----

\addcontentsline{toc}{subsection}{\T{lineto()}}
\phantomsection\label{sec:lineto}

\begin{bgi}
\V{} \func{lineto} (\I{} \A{x}, \I{} \A{y});
\end{bgi}

Draws a line from the CP to (\A{x}, \A{y}), then moves the CP to
(\A{dx}, \A{dy}).

% -----

\addcontentsline{toc}{subsection}{\T{moverel()}}
\phantomsection\label{sec:moverel}

\begin{bgi}
\V{} \func{moverel} (\I{} \A{dx}, \I{} \A{dy});
\end{bgi}

Moves the CP by (\A{dx}, \A{dy}) pixels.

% -----

\addcontentsline{toc}{subsection}{\T{moveto()}}
\phantomsection\label{sec:moveto}

\begin{bgi}
\V{} \func{moveto} (\I{} \A{x}, \I{} \A{y});
\end{bgi}

Moves the CP to the position (\A{x}, \A{y}), relative to the
viewport.

% -----

\addcontentsline{toc}{subsection}{\T{outtext()}}
\phantomsection\label{sec:outtext}

\begin{bgi}
\V{} \func{outtext} (\C{}\A{textstring});
\end{bgi}

Outputs \A{textstring} at the CP.

% -----

\addcontentsline{toc}{subsection}{\T{outtextxy()}}
\phantomsection\label{sec:outtextxy}

\begin{bgi}
\V{} \func{outtextxy} (\I{} \A{x}, \I{} \A{y}, \C{}\A{textstring});
\end{bgi}

Outputs \A{textstring} at (\A{x}, \A{y}).

% -----

\addcontentsline{toc}{subsection}{\T{pieslice()}}
\phantomsection\label{sec:pieslice}

\begin{bgi}
\V{} \func{pieslice} (\I{} \A{x}, \I{} \A{y}, \I{} \A{stangle}, \I{}
\A{endangle}, \I{} \A{radius});
\end{bgi}

Draws and fills a pie slice centered at (\A{x}, \A{y}), with a radius
given by \A{radius}, traveling from \A{stangle} to \A{endangle}. The
pie slice is filled using the current fill colour.

% -----

\addcontentsline{toc}{subsection}{\T{putimage()}}
\phantomsection\label{sec:putimage}

\begin{bgi}
\V{} \func{putimage} (\I{} \A{left}, \I{} \A{top}, \V{} \A{*bitmap},
\I{} \A{op});
\end{bgi}

Puts the bit image pointed to by \A{bitmap} onto the screen, with the
upper left corner of the image placed at (\A{left}, \A{top}). \A{op}
specifies the drawing mode (\T{COPY\_PUT}, etc).

% -----

\addcontentsline{toc}{subsection}{\T{putpixel()}}
\phantomsection\label{sec:putpixel}

\begin{bgi}
\V{} \func{putpixel} (\I{} \A{x}, \I{} \A{y}, \I{} \A{color});
\end{bgi}

Plots a pixel at (\A{x}, \A{y}) in the colour defined by \A{color}.

% -----

\addcontentsline{toc}{subsection}{\T{rectangle()}}
\phantomsection\label{sec:rectangle}

\begin{bgi}
\V{} \func{rectangle} (\I{} \A{left}, \I{} \A{top}, \I{} \A{right},
\I{} \A{bottom});
\end{bgi}

Draws a rectangle delimited by (\A{left}, \A{top}) and
(\A{right}, \A{bottom}).

% -----

\addcontentsline{toc}{subsection}{\T{registerbgidriver()}}
\phantomsection\label{sec:registerbgidriver}

\begin{bgi}
\I{} \func{registerbgidriver} (\V{} (\A{*driver})(\V{}));
\end{bgi}

Unimplemented; not used by \SDLbgi.

% -----

\addcontentsline{toc}{subsection}{\T{registerbgifont()}}
\phantomsection\label{sec:registerbgifont}

\begin{bgi}
\I{} \func{registerbgifont} (\V{} (\A{*font})(\V{}));
\end{bgi}

Unimplemented; not used by \SDLbgi.

% -----

\addcontentsline{toc}{subsection}{\T{restorecrtmode()}}
\phantomsection\label{sec:restorecrtmode}

\begin{bgi}
\V{} \func{restorecrtmode} (\V{});
\end{bgi}

Hides the graphics window.

% -----

\addcontentsline{toc}{subsection}{\T{sector()}}
\phantomsection\label{sec:sector}

\begin{bgi}
\V{} \func{sector} (\I{} \A{x}, \I{} \A{y}, \I{} \A{stangle}, \I{}
\A{endangle}, \I{} \A{xradius}, \I{} \A{yradius});
\end{bgi}

Draws and fills an elliptical pie slice centered at (\A{x}, \A{y}),
horizontal and vertical radii given by \A{xradius} and \A{yradius},
traveling from \A{stangle} to \A{endangle}.

% -----

\addcontentsline{toc}{subsection}{\T{setactivepage()}}
\phantomsection\label{sec:setactivepage}

\begin{bgi}
\V{} \func{setactivepage} (\I{} \A{page});
\end{bgi}

Makes \A{page} the active page for all subsequent graphics output. In
multi-window mode, \func{setactivepage()} only works for the first window.

% -----

\addcontentsline{toc}{subsection}{\T{setallpalette()}}
\phantomsection\label{sec:setallpalette}

\begin{bgi}
\V{} \func{setallpalette} (\T{struct palettetype *}\A{palette});
\end{bgi}

Sets the current palette to the values stored in \A{palette}.

% -----

\addcontentsline{toc}{subsection}{\T{setaspectratio()}}
\phantomsection\label{sec:setaspectratio}

\begin{bgi}
\V{} \func{setaspectratio} (\I{} \A{xasp}, \I{} \A{yasp});
\end{bgi}

Changes the default aspect ratio of the graphics. In \SDLbgi, this
function is not necessary since the pixels are square.

% -----

\addcontentsline{toc}{subsection}{\T{setbkcolor()}}
\phantomsection\label{sec:setbkcolor}

\begin{bgi}
\V{} \func{setbkcolor} (\I{} \A{color});
\end{bgi}

Sets the current background colour.

% -----

\addcontentsline{toc}{subsection}{\T{setcolor()}}
\phantomsection\label{sec:setcolor}

\begin{bgi}
\V{} \func{setcolor} (\I{} \A{color});
\end{bgi}

Sets the current drawing colour. If ARGB colours are not being used
and \A{color} $>$ \T{MAXCOLORS}, then set \A{color} \% \T{MAXCOLORS}.

% -----

\addcontentsline{toc}{subsection}{\T{setfillpattern()}}
\phantomsection\label{sec:setfillpattern}

\begin{bgi}
\V{} \func{setfillpattern} (\C{}\A{upattern}, \I{} \A{color});
\end{bgi}

Sets a user-defined fill pattern. \A{upattern} is a pointer to a
sequence of 8 bytes; each byte corresponds to 8 pixels in the pattern;
each bit set to 1 is plotted as a pixel.

% -----

\addcontentsline{toc}{subsection}{\T{setfillstyle()}}
\phantomsection\label{sec:setfillstyle}

\begin{bgi}
\V{} \func{setfillstyle} (\I{} \A{upattern}, \I{} \A{color});
\end{bgi}

Sets the fill pattern and fill colour. \A{upattern} is a pointer to a
sequence of 8 bytes, with each byte corresponding to 8 pixels in the
pattern.

% -----

\addcontentsline{toc}{subsection}{\T{setgraphbufsize()}}
\phantomsection\label{sec:setgraphbufsize}

\begin{bgi}
unsigned \func{setgraphbufsize} (\T{unsigned} \A{bufsize});
\end{bgi}

Unimplemented; not used by \SDLbgi.

% -----

\addcontentsline{toc}{subsection}{\T{setgraphmode()}}
\phantomsection\label{sec:setgraphmode}

\begin{bgi}
\V{} \func{setgraphmode} (\I{} \A{mode});
\end{bgi}

Shows the window that was hidden by \func{restorecrtmode()}. The
\A{mode} parameter is ignored,

% -----

\addcontentsline{toc}{subsection}{\T{setlinestyle()}}
\phantomsection\label{sec:setlinestyle}

\begin{bgi}
\V{} \func{setlinestyle} (\I{} \A{linestyle}, \T{unsigned}
\A{upattern}, \I{} \A{thickness});
\end{bgi}

Sets the line width and style for all lines drawn by \func{line()},
\func{lineto()}, \func{rectangle()}, \func{drawpoly()}, etc. The line
style can be \T{SOLID\_LINE}, \T{DOTTED\_LINE}, \T{CENTER\_LINE},
\T{DASHED\-\_LINE}, or \T{USERBIT\_LINE}; in the latter case, the user
provides a 16-bit number (\A{upattern}) whose bits set to 1 will be
plotted as pixels.

The line thickness can be set with \T{NORM\_WIDTH} or
\T{THICK\-\_WIDTH}.

Arcs, circles, ellipses, and pieslices are not affected by
\A{linestyle}, but are affected by \A{thickness}.

% -----

\addcontentsline{toc}{subsection}{\T{setpalette()}}
\phantomsection\label{sec:setpalette}

\begin{bgi}
\V{} \func{setpalette} (\I{} \A{colornum}, \I{} \A{color});
\end{bgi}

Changes the standard palette \A{colornum} to \A{color}, which can also
be specified using the \func{COLOR()} function; it also changes the
colour of currently drawn pixels.

% -----

\addcontentsline{toc}{subsection}{\T{settextjustify()}}
\phantomsection\label{sec:settextjustify}

\begin{bgi}
\V{} \func{settextjustify} (\I{} \A{horiz}, \I{} \A{vert});
\end{bgi}

Sets text justification. Text output will be justified around the CP
horizontally and vertically; settings are \T{LEFT\_TEXT},
\T{CENTER\_TEXT}, \T{RIGHT\-\_TEXT}, \T{BOTTOM\_TEXT}, and
\T{TOP\_TEXT}.

% -----

\addcontentsline{toc}{subsection}{\T{settextstyle()}}
\phantomsection\label{sec:settextstyle}

\begin{bgi}
\V{} \func{settextstyle} (\I{} \A{font}, \I{} \A{direction}, \I{}
\A{charsize});
\end{bgi}

Sets the text font (8$\times$8 bitmap font \T{DEFAULT\_FONT} and
vector fonts \T{TRIPLEX\_FONT}, \T{SMALL\-\_FONT},
\T{SANS\_SERIF\_FONT}, \T{GOTHIC\_FONT}, \T{SCRIPT\_FONT},
\T{SIMPLEX\_FONT}, \T{TRI\-PLEX\_SCR\_FONT}), the text direction
(\T{HORIZ\_DIR}, \T{VERT\_DIR}), and the size of the characters.

\A{charsize} is a scaling factor for the text (max. 10). If
\A{charsize} is 0, the text will either use the default size, or it
will be scaled by the values set with \func{setusercharsize()}.

Experimental feature: if a \file{.CHR} font is available in the same
directory as the running program, it will be loaded and used instead
of its internal equivalent.

\emph{Note:} pixel-perfect font metrics are not supported yet.

% -----

\addcontentsline{toc}{subsection}{\T{setusercharsize()}}
\phantomsection\label{sec:setusercharsize}

\begin{bgi}
\V{} \func{setusercharsize} (\I{} \A{multx}, \I{} \A{divx}, \I{}
\A{multy}, \I{} \A{divy});
\end{bgi}

Lets the user change the character width and height. If a previous
call to \func{settextsty\-le()} set \A{charsize} to 0, the default
width is scaled by \A{multx}/\A{divx}, and the default height is
scaled by \A{multy}/\A{divy}.

% -----

\addcontentsline{toc}{subsection}{\T{setviewport()}}
\phantomsection\label{sec:setviewport}

\begin{bgi}
\V{} \func{setviewport} (\I{} \A{left}, \I{} \A{top}, \I{} \A{right},
\I{} \A{bottom}, \I{} \A{clip});
\end{bgi}

Sets the current viewport for graphics output. If \A{clip} is nonzero,
all drawings will be clipped (truncated) to the current viewport.

% -----

\addcontentsline{toc}{subsection}{\T{setvisualpage()}}
\phantomsection\label{sec:setvisualpage}

\begin{bgi}
\V{} \func{setvisualpage} (\I{} \A{page});
\end{bgi}

Sets the visual graphics page number. In ``fast mode'', the screen is
not cleared.

% -----

\addcontentsline{toc}{subsection}{\T{setwritemode()}}
\phantomsection\label{sec:setwritemode}

\begin{bgi}
\V{} \func{setwritemode} (\I{} \A{mode});
\end{bgi}

Sets the writing mode for line drawing. \A{mode} can be \T{COPY\_PUT},
\T{XOR\-\_PUT}, \T{OR\_PUT}, \T{AND\_PUT}, and \T{NOT\_PUT}.

% -----

\addcontentsline{toc}{subsection}{\T{textheight()}}
\phantomsection\label{sec:textheight}

\begin{bgi}
\I{} \func{textheight} (\C{}\A{textstring});
\end{bgi}

Returns the height in pixels of a string.

% -----

\addcontentsline{toc}{subsection}{\T{textwidth()}}
\phantomsection\label{sec:textwidth}

\begin{bgi}
\I{} \func{textwidth} (\C{}\A{textstring});
\end{bgi}

Returns the width in pixels of a string.

% -----

\section{Non-Graphics Functions and Macros}

\begin{bgi}
\V{} \func{delay} (\I{} \A{millisec});
\end{bgi}

Waits for \A{millisec} milliseconds. In ``slow mode'', a screen
refresh is performed.

\emph{Note}: in Turbo C, this function was provided by \T{DOS.H}.

% -----

\addcontentsline{toc}{subsection}{\T{getch()}}
\phantomsection\label{sec:getch}

\begin{bgi}
\I{} \func{getch} (\V{});
\end{bgi}

Waits for a key and returns its ASCII or key code (i.e.\ \T{KEY\_*}).
In ``slow mode'', a screen refresh is performed. If an \T{SDL\_QUIT}
event occurs, \T{QUIT} is returned.

\emph{Note}: in Turbo C, this function was provided by \T{CONIO.H}.

% -----

\addcontentsline{toc}{subsection}{\T{kbhit()}}
\phantomsection\label{sec:kbhit}

\begin{bgi}
\I{} \func{kbhit} (\V{});
\end{bgi}

Returns 1 when a key is pressed, excluding special keys (Ctrl, Shift,
etc.); in ``slow mode'', a screen refresh is performed. If an
\T{SDL\_QUIT} event occurs, \T{QUIT} is returned.

\emph{Note}: in Turbo C, this function was provided by \T{CONIO.H}.

% -----

\addcontentsline{toc}{subsection}{\T{lastkey()}}
\phantomsection\label{sec:lastkey}

\begin{bgi}
\I{} \func{lastkey} (\V{});
\end{bgi}

Returns the last key that was detected by \func{kbhit()}.

% -----

\addcontentsline{toc}{subsection}{\T{random()}}
\phantomsection\label{sec:random}

\begin{bgi}
\I{} \func{random} (\I{} \A{range}) (macro)
\end{bgi}

Returns a random number between 0 and \A{range - 1}.

\emph{Note}: in Turbo C, this function was provided by \T{STDLIB.H}.

% -----

% =====

\section{\SDLbgi{} Additions}

The following \SDLbgi{} extensions are mostly compatible with those
made available by WinBGIm.

% -----

\addcontentsline{toc}{subsection}{\T{ALPHA\_VALUE()}}
\phantomsection\label{sec:ALPHAVALUE}

\begin{bgi}
\I{} \func{ALPHA\_VALUE} (\I{} \A{color})
\end{bgi}

Returns the alpha (transparency) component of an ARGB colour in the
ARGB palette.

% -----

\addcontentsline{toc}{subsection}{\T{BLUE\_VALUE()}}
\phantomsection\label{sec:BLUEVALUE}

\begin{bgi}
\I{} \func{BLUE\_VALUE} (\I{} \A{color})
\end{bgi}

Returns the blue component of an ARGB colour in the ARGB palette.

% -----

\addcontentsline{toc}{subsection}{\T{COLOR()}}
\phantomsection\label{sec:COLOR}

\begin{bgi}
\I{} \func{COLOR} (\I{} \A{r}, \I{} \A{g}, \I{} \A{b});
\end{bgi}

Can be used as colour argument for \func{getbkcolor()},\ 
\func{getcolor()},\ \func{putpixel()},\ \func{set\-bkcolor()}
\func{setbkcolor()},\ \func{setcolor()},\ \func{setfillpattern()},
\func{setfillstyle()},\ and \func{setpalette()}\ to set a colour
specifying its ARGB components. The colour index is
\T{ARGB\_TMP\_COL}.

Functions \func{ALPHA\_VALUE()}, \func{BLUE\_VALUE()},
\func{GREEN\_VALUE()}, and \func{RED\_VALUE()} do not work on
temporary colours.

% -----

\addcontentsline{toc}{subsection}{\T{COLOR32()}}
\phantomsection\label{sec:COLOR32}

\begin{bgi}
\I{} \func{COLOR32} (\I{} \Ut{color});
\end{bgi}

Can be used as colour argument for \func{getbkcolor()},\ 
\func{getcolor()},\ \func{putpixel()},\ \func{set\-bkcolor()},\ 
\func{setcolor()},\ \func{setfillpattern()},\ \func{setfillstyle()},\
and \func{setpalette()} to set a colour as ARGB integer. The colour
index is \T{ARGB\_TMP\_COL}.

Functions \func{ALPHA\_VALUE()}, \func{BLUE\_VALUE()},
\func{GREEN\_VALUE()}, and \func{RED\_VALUE()} do not work on
temporary colours.

% -----

\addcontentsline{toc}{subsection}{\T{colorRGB()}}
\phantomsection\label{sec:colorRGB}

\begin{bgi}
\I{} \func{colorRGB} (\I{} \A{r}, \I{} \A{g}, \I{} \A{b}) (macro)
\end{bgi}

Can be used to compose a 32 bit colour with \A{r} \A{g} \A{b}
components; the alpha value is set to \T{0xff}. This macro is
typically used to set values in memory buffers.

% -----

\addcontentsline{toc}{subsection}{\T{GREEN\_VALUE()}}
\phantomsection\label{sec:GREENVALUE}

\begin{bgi}
\I{} \func{GREEN\_VALUE} (\I{} \A{color})
\end{bgi}

Returns the green component of an ARGB colour in the ARGB palette.

% -----

\addcontentsline{toc}{subsection}{\T{IS\_BGI\_COLOR()}}
\phantomsection\label{sec:ISBGICOLOR}

\begin{bgi}
\I{} \func{IS\_BGI\_COLOR} (\I{} \A{color});
\end{bgi}

Returns 1 if the \emph{current} drawing colour is a standard BGI
colour (that is, not ARGB). The \A{color} argument is actually redundant.

% -----

\addcontentsline{toc}{subsection}{\T{IS\_RGB\_COLOR()}}
\phantomsection\label{sec:ISRGBCOLOR}

\begin{bgi}
\I{} \func{IS\_RGB\_COLOR} (\I{} \A{color});
\end{bgi}

Returns 1 if the \emph{current} drawing colour is ARGB. The \A{color}
argument is actually redundant.

% -----

\addcontentsline{toc}{subsection}{\T{RED\_VALUE()}}
\phantomsection\label{sec:REDVALUE}

\begin{bgi}
\I{} \func{RED\_VALUE} (\I{} \A{color})
\end{bgi}

Returns the red component of an ARGB colour in the ARGB palette.

% -----

\addcontentsline{toc}{subsection}{\T{RGBPALETTE()}}
\phantomsection\label{sec:RGBPALETTE}

\begin{bgi}
\I{} \func{RGBPALETTE} (\I{} \A{color});
\end{bgi}

Can be used as a colour argument for \func{getbkcolor()},
\func{getcolor()}, \func{putpixel()}, \func{setbkcolor()}
\func{setbkcolor()}, \func{setcolor()}, \func{setfillpattern()},
\func{setfillstyle()} and \func{setpalette()} to set the colour from
the ARGB palette \A{color} entry. The colour index is
\T{ARGB\_TMP\_COL}.

Functions \func{ALPHA\_VALUE()}, \func{BLUE\_VALUE()},
\func{GREEN\_VALUE()}, and \func{RED\_VALUE()} do not work on temporary
colours.

% -----

\addcontentsline{toc}{subsection}{\T{\_putpixel()}}
\phantomsection\label{sec:pputpixel}

\begin{bgi}
\V{} \func{\_putpixel} (\I{} \A{x}, \I{} \A{y});
\end{bgi}

Plots a point at (\A{x}, \A{y}) using the current drawing colour. This
function may be faster than \func{putpixel()}.

% -----

\addcontentsline{toc}{subsection}{\T{closewindow()}}
\phantomsection\label{sec:closewindow}

\begin{bgi}
\V{} \func{closewindow} (\I{} \A{id});
\end{bgi}

Closes the window identified by \A{id}.

% -----

\addcontentsline{toc}{subsection}{\T{copysurface()}}
\phantomsection\label{sec:copysurface}

\begin{bgi}
\V{} \func{copysurface} (\T{SDL\_Surface} \A{surface}, 
\I{} \A{x1}, \I{} \A{y1}, \I{} \A{x2}, \I{} \A{y2});
\end{bgi}

Copies \A{surface} to the rectangle defined by \A{x1}, \A{y1}, \A{x2},
\A{y2} and displays it immediately. If \A{x2} or \A{y2} equals 0, then
the original surface size will be used. 

% -----

\begin{bgi}
\I{} \func{doubleclick} (\V{});
\end{bgi}

Returns 1 if the last mouse click was a double click.

% -----

\begin{bgi}
\I{} \func{edelay} (\I{} \A{msec});
\end{bgi}

Waits for \A{msec} milliseconds. In ``slow mode'', a screen
refresh is performed. If an event occurs during the delay, this
function returns 1, otherwise 0. Use \func{eventtype()} to get the last
event.

% -----

\addcontentsline{toc}{subsection}{\T{event()}}
\phantomsection\label{sec:event}

\begin{bgi}
\I{} \func{event} (\V{});
\end{bgi}

Returns 1 if one of the following events has occurred:
\T{SDL\_KEYDOWN}, \T{SDL\_MOU\-SEBUT\-TONDOWN}, \T{SDL\_MOUSEWHEEL},
or \T{SDL\_QUIT}; 0 otherwise.

% -----

\addcontentsline{toc}{subsection}{\T{eventtype()}}
\phantomsection\label{sec:eventtype}

\begin{bgi}
\I{} \func{eventtype} (\V{});
\end{bgi}

Returns the type of the last event. Reported events are
\T{SDL\_KEYDOWN}, \T{SDL\_MOUSEMOTION}, \T{SDL\_MOUSEBUTTONDOWN},
\T{SDL\_MOUSEBUTTONUP}, \T{SDL\_MOUSEWHEEL}, and \T{SDL\_QUIT}.

% -----

\addcontentsline{toc}{subsection}{\T{getbuffer()}}
\phantomsection\label{sec:getbuffer}

\begin{bgi}
\V{} \func{getbuffer} (\Ut{} \A{*buffer});
\end{bgi}

Copies the contents of the active window to \A{buffer}, which must be
a (\func{getmaxy() + 1}) $\times$ (\func{getmaxx() + 1}) array of
\A{Uint32}. Copied elements are in ARGB format.

% -----

\addcontentsline{toc}{subsection}{\T{getclick()}}
\phantomsection\label{sec:getclick}

\begin{bgi}
\I{} \func{getclick} (\V{});
\end{bgi}

Waits for a mouse click and returns the button that was clicked.

% -----

\addcontentsline{toc}{subsection}{\T{getcurrentwindow()}}
\phantomsection\label{sec:getcurrentwindow}

\begin{bgi}
\I{} \func{getcurrentwindow} (\V{});
\end{bgi}

Returns the \A{id} of the current window.

% -----

\addcontentsline{toc}{subsection}{\T{getevent()}}
\phantomsection\label{sec:getevent}

\begin{bgi}
\I{} \func{getevent} (\V{});
\end{bgi}

Waits for one of the following events: \T{SDL\_KEYDOWN},
\T{SDL\_MOUSEBUTTONDOWN}, \T{SDL\_MOU\-SEWHEEL}, and \T{SDL\_QUIT}. It
returns the code of the key, or the mouse button, either 
\T{WM\_WHEELUP} or \T{WM\_WHEELDOWN}, or \T{SDL\_QUIT}.

% -----

\addcontentsline{toc}{subsection}{\T{getleftclick()}}
\phantomsection\label{sec:getleftclick}

\begin{bgi}
\V{} \func{getleftclick} (\V{});
\end{bgi}

Waits for the left mouse button to be clicked and released.

% -----

\addcontentsline{toc}{subsection}{\T{getlinebuffer()}}
\phantomsection\label{sec:getlinebuffer}

\begin{bgi}
\V{} \func{getlinebuffer} (\I{} \A{y}, \Ut{} \A{*linebuffer});
\end{bgi}

Copies the \A{y}-th screen line to \A{linebuffer}, which must be a
\func{getmaxx()+1} array of \A{Uint32} in ARGB format.

% -----

\addcontentsline{toc}{subsection}{\T{getmaxheight()}}
\phantomsection\label{sec:getmaxheight}

\begin{bgi}
\I{} \func{getmaxheight} (\V{});
\end{bgi}

Returns the maximum possible height for a new window (actual screen
height in pixels). This function may be called before graphics
initialisation.

% -----

\addcontentsline{toc}{subsection}{\T{getmaxwidth()}}
\phantomsection\label{sec:getmaxwidth}

\begin{bgi}
\I{} \func{getmaxwidth} (\V{});
\end{bgi}

Returns the maximum possible width for a new window (actual screen
width in pixels). This function may be called before graphics
initialisation.

% -----

\addcontentsline{toc}{subsection}{\T{getmiddleclick()}}
\phantomsection\label{sec:getmiddleclick}

\begin{bgi}
\V{} \func{getmiddleclick} (\V{});
\end{bgi}

Waits for the middle mouse button to be clicked and released.

% -----

\addcontentsline{toc}{subsection}{\T{getmouseclick()}}
\phantomsection\label{sec:getmouseclick}

\begin{bgi}
\V{} \func{getmouseclick} (\I{} \A{kind}, \I{}\A{*x}, \I{}\A{*y});
\end{bgi}

Sets the \A{x}, \A{y} coordinates of the last \A{kind} button click
expected by \func{ismouseclick()}.

% -----

\addcontentsline{toc}{subsection}{\T{getrgbpalette()}}
\phantomsection\label{sec:getrgbpalette}

\begin{bgi}
\V{} \func{getrgbpalette} (\T{struct rgbpalettetype} \A{*palette});
\end{bgi}

Fills the \T{rgbpalettetype} structure pointed by \A{palette} with
information about the current ARGB palette's size and colours.

% -----

\addcontentsline{toc}{subsection}{\T{getrightclick()}}
\phantomsection\label{sec:getrightclick}

\begin{bgi}
\V{} \func{getrightclick} (\V{});
\end{bgi}

Waits for the right mouse button to be clicked and released.

% -----

\addcontentsline{toc}{subsection}{\T{getscreensize()}}
\phantomsection\label{sec:getscreensize}

\begin{bgi}
\V{} \func{getscreensize} (\I{} \A{*width}, \I{} \A{*height});
\end{bgi}

Reports the screen width and height in \A{width} and \A{height},
regardless of current window dimensions. This function may be called
before graphics initialisation.

% -----

\addcontentsline{toc}{subsection}{\T{getwindowheight()}}  (macro)
\phantomsection\label{sec:getwindowheight}

\begin{bgi}
\V{} \func{getwindowheight} (\V{});
\end{bgi}

Equivalent to \func{getmaxy()} (WinBGIm compatibility).

% -----

\addcontentsline{toc}{subsection}{\T{getwindowwidth()}}  (macro)
\phantomsection\label{sec:getwindowwidth}

\begin{bgi}
\V{} \func{getwindowwidth} (\V{});
\end{bgi}

Equivalent to \func{getmaxx()} (WinBGIm compatibility).

% -----

\addcontentsline{toc}{subsection}{\T{initpalette()}}
\phantomsection\label{sec:initpalette}

\begin{bgi}
\V{} \func{initpalette} (\V{});
\end{bgi}

Initialises the BGI palette to the standard 16 colours. If the
environment variable \T{SDL\_BGI\-\_PALET\-TE} equals \T{BGI}, the
first 16 colours will use the same RGB values as Turbo C 2.01;
otherwise, a brighter palette will be used.

% -----

\addcontentsline{toc}{subsection}{\T{initwindow()}}
\phantomsection\label{sec:initwindow}

\begin{bgi}
\V{} \func{initwindow} (\I{} \A{width}, \I{} \A{height});
\end{bgi}

Initializes the graphics system, opening a \A{width}$\times$\A{height}
window. If either \A{width} or \A{height} is 0, then
\T{SDL\-\_FULL\-SCREEN} will be used. Multiple windows can be created,
unless a fullscreen window is already present.

The user must update the screen as needed using \func{refresh()}, or
use \func{sdlbgiauto()}.

% -----

\addcontentsline{toc}{subsection}{\T{ismouseclick()}}
\phantomsection\label{sec:ismouseclick}

\begin{bgi}
\I{} \func{ismouseclick} (\I{} \A{kind});
\end{bgi}

Returns 1 if the \A{kind} mouse button was clicked.

% -----

\addcontentsline{toc}{subsection}{\T{mouseclick()}}
\phantomsection\label{sec:mouseclick}

\begin{bgi}
\I{} \func{mouseclick} (\V{});
\end{bgi}

Returns the code of the mouse button that is being clicked, or
\T{SDL\_MOUSEMOTION} if the mouse is being moved, or 0 if no mouse
event is occurring.

% -----

\addcontentsline{toc}{subsection}{\T{mousex()}}
\phantomsection\label{sec:mousex}

\begin{bgi}
\I{} \func{mousex} (\V{});
\end{bgi}

Returns the X coordinate of the last mouse click.

% -----

\addcontentsline{toc}{subsection}{\T{mousey()}}
\phantomsection\label{sec:mousey}

\begin{bgi}
\I{} \func{mousey} (\V{});
\end{bgi}

Returns the Y coordinate of the last mouse click.

% -----

\addcontentsline{toc}{subsection}{\T{putbuffer()}}
\phantomsection\label{sec:putbuffer}

\begin{bgi}
\V{} \func{putbuffer} (\Ut{} \A{*buffer});
\end{bgi}

Copies \A{buffer} to the current window. \A{buffer} must be a
(\func{getmaxy() + 1}) $\times$ (\func{getmaxx() + 1}) array of
\A{Uint32} in ARGB format. This function is faster than direct pixel
manipulation.

% -----

\addcontentsline{toc}{subsection}{\T{putlinebuffer()}}
\phantomsection\label{sec:putlinebuffer}

\begin{bgi}
\V{} \func{putlinebuffer} (\I{} \A{y}, \Ut{} \A{*buffer});
\end{bgi}

Copies \A{linebuffer} to the \A{y} coordinate in the current window.
\A{linebuffer} must be a \func{get\-maxx()+1} array of \A{Uint32} in
ARGB format. This function is faster than direct pixel manipulation.

% -----

\addcontentsline{toc}{subsection}{\T{readimagefile()}}
\phantomsection\label{sec:readimagefile}

\begin{bgi}
\V{} \func{readimagefile} (\C{}\A{filename}, \I{} \A{x1}, \I{} \A{y1},
\I{} \A{x2}, \I{} \A{y2});
\end{bgi}

Reads a \F{.bmp} file and displays it immediately at (\A{x1}, \A{y1}).
If (\A{x2}, \A{y2}) are not 0, the bitmap is stretched to fit the
rectangle \A{x1}, \A{y1}---\A{x2}, \A{y2}; otherwise, the bitmap is
clipped as necessary.

% -----

\addcontentsline{toc}{subsection}{\T{refresh()}}
\phantomsection\label{sec:refresh}

\begin{bgi}
\V{} \func{refresh} (\V{});
\end{bgi}

Updates the screen contents, i.e.\ displays all graphics.

% -----

\addcontentsline{toc}{subsection}{\T{resetwinoptions()}}
\phantomsection\label{sec:resetwinoptions}

\begin{bgi}
\V{} \func{setwinoptions} (\I{} \A{id}, \C{}\A{title}, \I{} \A{x}, \I{} \A{y});
\end{bgi}

Resets the window title \A{title} and position to (\A{x}, \A{y}) of an
existing window identified by \A{id}. \A{x} and \A{y} can be set to
\T{SDL\_WINDOWPOS\_CENTERED} or \T{SDL\_WINDOWPOS\_UNDEFINED}.

% If \A{title} is an empty string, the window title is set to the
% default value \T{SDL\_bgi}.

If either \A{x} or \A{y} is -1, the position parameters are ignored.

% -----

\addcontentsline{toc}{subsection}{\T{resizepalette()}}
\phantomsection\label{sec:resizepalette}

\begin{bgi}
\I{} \func{resizepalette} (\Ut{} \A{newsize});
\end{bgi}

Resizes the ARGB palette to \A{newsize}; returns 0 if successful, 1
otherwise. The initial size of the ARGB palette is 4096.

% -----

\addcontentsline{toc}{subsection}{\T{sdlbgiauto()}}
\phantomsection\label{sec:sdlbgiauto}

\begin{bgi}
\V{} \func{sdlbgiauto} (\V{});
\end{bgi}

Triggers ``auto mode'', i.e.\ \func{refresh()} is performed
automatically. Caveat: it may not work on some graphics cards.

% -----

\addcontentsline{toc}{subsection}{\T{sdlbgifast()}}
\phantomsection\label{sec:sdlbgifast}

\begin{bgi}
\V{} \func{sdlbgifast} (\V{});
\end{bgi}

Triggers ``fast mode'', i.e.\ \func{refresh()} is needed to display
graphics.

% -----

\addcontentsline{toc}{subsection}{\T{sdlbgislow()}}
\phantomsection\label{sec:sdlbgislow}

\begin{bgi}
\V{} \func{sdlbgislow} (\V{});
\end{bgi}

Triggers ``slow mode'', i.e.\ \func{refresh()} is not needed to
display graphics.

% -----

\addcontentsline{toc}{subsection}{\T{setallrgbpalette()}}
\phantomsection\label{sec:setallrgbpalette}

\begin{bgi}
\V{} \func{setallrgbpalette} (\T{struct rgbpalettetype *}\A{palette});
\end{bgi}

Sets the current ARGB palette to the values stored in \A{palette}.

% -----

\addcontentsline{toc}{subsection}{\T{setalpha()}}
\phantomsection\label{sec:setalpha}

\begin{bgi}
\V{} \func{setalpha} (\I{} \A{col}, \Ue{} \A{alpha});
\end{bgi}

Sets alpha transparency for colour \A{col} to \A{alpha} (0--255); 0
means full transparecy, 255 full opacity. \func{setalpha()} works with
colours in both palettes.

% -----

\addcontentsline{toc}{subsection}{\T{setbkrgbcolor()}}
\phantomsection\label{sec:setbkrgbcolor}

\begin{bgi}
\V{} \func{setbkrgbcolor} (\I{} \A{n});
\end{bgi}

Sets the current background colour using the \A{n}-th colour entry in
the ARGB palette.

% -----

\addcontentsline{toc}{subsection}{\T{setblendmode()}}
\phantomsection\label{sec:setblendmode}

\begin{bgi}
\V{} \func{setblendmode} (\I{} \A{blendmode});
\end{bgi}

Sets the blend mode to be used with screen refresh. \A{blendmode} can
be \T{SDL\_BLENDMODE\-\_NONE} (default in ``slow mode'') or
\T{SDL\_BLENDMODE\_BLEND}. The latter enables alpha blending.

% -----

\addcontentsline{toc}{subsection}{\T{setcurrentwindow()}}
\phantomsection\label{sec:setcurrentwindow}

\begin{bgi}
\V{} \func{setcurrentwindow} (\I{} \A{id});
\end{bgi}

Sets the current active window to \A{id}.

% -----

\addcontentsline{toc}{subsection}{\T{setrgbcolor()}}
\phantomsection\label{sec:setrgbcolor}

\begin{bgi}
\V{} \func{setrgbcolor} (\I{} \A{n});
\end{bgi}

Sets the current drawing colour using the \A{n}-th colour entry in the
ARGB palette.

% -----

\addcontentsline{toc}{subsection}{\T{setrgbpalette()}}
\phantomsection\label{sec:setrgbpalette}

\begin{bgi}
\V{} \func{setrgbpalette} (\I{} \A{n}, \I{} \A{r}, \I{} \A{g}, \I{} \A{b});
\end{bgi}

Sets the \A{n}-th entry in the ARGB palette specifying the \A{r},
\A{g}, and \A{b} components.

Using \func{setrgbpalette()} and \func{setrgbcolor()} is faster than
setting colours with \func{setco\-lor()} with a \func{COLOR()}
argument. It does not change the colour of currently drawn pixels.

% -----

\addcontentsline{toc}{subsection}{\T{setwinoptions()}}
\phantomsection\label{sec:setwinoptions}

\begin{bgi}
\V{} \func{setwinoptions} (\C{}\A{title}, \I{} \A{x}, \I{} \A{y},
  \Ut{} \A{flags});
\end{bgi}

Sets the window title \A{title}, the initial position to (\A{x},
\A{y}), and SDL2 flags OR'ed together. \A{x} and \A{y} can be set to
\T{SDL\_WINDOWPOS\_CENTERED} or \T{SDL\_WINDOWPOS\_UNDEFI\-NED}.

If \A{title} is an empty string, the window title is set to the
default value \T{SDL\_bgi}.

If either \A{x} or \A{y} is -1, the position parameters are ignored.

If \A{flags} is -1, the parameter is ignored; otherwise, only the
values \T{SDL\_WINDOW\_FULL\-SCREEN},
\T{SDL\_WIN\-DOW\_FULLSCREEN\_DESKTOP}, \T{SDL\_WINDOW\_SHOWN},
\T{SDL\_WINDOW\_HIDDEN}, \T{SDL\_WINDOW\-\_BORDERLESS}, and
\T{SDL\_WINDOW\_MINIMIZED} can be applied.

% -----

\addcontentsline{toc}{subsection}{\T{setwintitle()}}
\phantomsection\label{sec:setwintitle}

\begin{bgi}
\V{} \func{setwintitle} (\I{id}, \C{}\A{title});
\end{bgi}

Sets the title of the window identified by \A{id}.

% -----

\addcontentsline{toc}{subsection}{\T{showerrorbox()}}
\phantomsection\label{sec:showerrorbox}

\begin{bgi}
\V{} \func{showerrorbox} (const \C{}\A{message});
\end{bgi}

Opens an error message box with the specified message. The message box
waits for the user to click on the OK button.

% -----

\addcontentsline{toc}{subsection}{\T{showinfobox()}}
\phantomsection\label{sec:showinfobox}

\begin{bgi}
\V{} \func{showinfobox} (const \C{}\A{message});
\end{bgi}

Opens an information message box with the specified message. The
message box waits for the user to click on the OK button.

% -----

\addcontentsline{toc}{subsection}{\T{swapbuffers()}}
\phantomsection\label{sec:swapbuffers}

\begin{bgi}
\I{} \func{swapbuffers} (\V{});
\end{bgi}

Swaps the current active and the current visual graphics pages.

% -----

\addcontentsline{toc}{subsection}{\T{writeimagefile()}}
\phantomsection\label{sec:writeimagefile}

\begin{bgi}
\V{} \func{writeimagefile} (\C{}\A{filename}, \I{} \A{left}, \I{}
\A{top}, \I{} \A{right}, \I{} \A{bottom});
\end{bgi}

Writes a \F{.bmp} file from the screen rectangle defined by
\A{left}, \A{top}---\A{right}, \A{bottom}.

% -----

\addcontentsline{toc}{subsection}{\T{xkbhit()}}
\phantomsection\label{sec:xkbhit}

\begin{bgi}
\I{} \func{xkbhit} (\V{});
\end{bgi}

Returns 1 when any key is pressed, including special keys (Ctrl, Shift,
etc.); in ``slow mode'', a screen refresh is performed. If an
\T{SDL\_QUIT} event occurs, \T{QUIT} is returned.

% =====

\bigskip

\rule{\linewidth}{0.2pt}

This document is a free manual, released under the GNU Free
Documentation License (FDL) v. 1.3 or later.

\end{document}

% ----- end of file sdl_bgi-quickref.tex
